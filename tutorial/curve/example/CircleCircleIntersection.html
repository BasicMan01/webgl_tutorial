<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<script type="text/javascript" src="../../../lib/datgui/dat.gui.min.js"></script>
		
		<script type="text/javascript" src="../../../lib/threejs_85/three.min.js"></script>
		<script type="text/javascript" src="../../../lib/threejs_85/controls/OrbitControls.js"></script>

		<link rel="stylesheet" type="text/css" href="../../../resources/css/global.css">
	</head>

	<body>
		<div id="webGLCanvas" oncontextmenu="return false">
			<div class="tags">
				<ul>
					<li>OrbitControls</li>
					<li>AxisHelper</li>
					<li>GridHelper</li>
					<li>EllipseCurve</li>
				</ul>
			</div>
			
			<div id="output" class="output"></div>
		</div>
		
		<script type="text/javascript">
			var RDO = window.RDO || {};
			
			RDO.Vector3 = function(x, y, z)
			{
				var self = this;
				
				if(x === undefined) x = 0;
				if(y === undefined) y = 0;
				if(z === undefined) z = 0;

				this.x = x;
				this.y = y;
				this.z = z;
				
				this.add = function(vector)
				{
					return new RDO.Vector3(self.x + vector.x, self.y + vector.y, self.z + vector.z);
				};
				
				this.sub = function(vector)
				{
					return new RDO.Vector3(self.x - vector.x, self.y - vector.y, self.z - vector.z);
				};
				
				this.toString = function()
				{
					return 'x: ' + this.x + ', y: ' + this.y + ', z: ' + this.z;
				};
			};

			RDO.Tutorial = {
				'CAMERA_FOV': 70,
				'CAMERA_NEAR_PLANE': 0.1,
				'CAMERA_FAR_PLANE': 500
			};
			
			RDO.Tutorial.Properties = {
				'axisHelperVisible': true,
				'gridHelperVisible': false,
				'circle1CenterX': 4.5,
				'circle1CenterY': 6,
				'circle1Radius': 5,
				'circle1Color': '#FFFFFF',
				'circle2CenterX': 5.5,
				'circle2CenterY': -1,
				'circle2Radius': 5,
				'circle2Color': '#FFFFFF',
				'circle3CenterX': -3.5,
				'circle3CenterY': 2,
				'circle3Radius': 5,
				'circle3Color': '#FFFFFF',
				'circlePoints': 50,
				'circleTolerance': 0
			};
			
			RDO.Tutorial.Main = function(canvas)
			{
				var camera;
				var controls;
				var gui = new dat.GUI({ width: 400 });
				var renderer;
				var scene;
				
				var axisHelper;
				var gridHelper;
				
				var circle1;
				var circle2;
				var circle3;
				var lineCenterToCenter;
				var lineIntersectToIntersect = [];
				
				function constructor()
				{
					scene = new THREE.Scene();

					camera = new THREE.PerspectiveCamera(RDO.Tutorial.CAMERA_FOV, getCameraAspect(), RDO.Tutorial.CAMERA_NEAR_PLANE, RDO.Tutorial.CAMERA_FAR_PLANE);
					camera.position.set(0, 0, 20);
					
					renderer = new THREE.WebGLRenderer({antialias: true});
					renderer.setClearColor(0x000000, 1);
					renderer.setPixelRatio(window.devicePixelRatio);
					renderer.setSize(getGameAreaWidth(), getGameAreaHeight());
					
					controls = new THREE.OrbitControls(camera, renderer.domElement);
					
					// add renderer to the DOM-Tree
					canvas.appendChild(renderer.domElement);
					
					createGui();
					createObject();
		
					render();
					
					window.addEventListener('resize', onResizeHandler, false);
				}
				
				function createObject()
				{
					axisHelper = new THREE.AxisHelper(25);
					scene.add(axisHelper);
					
					gridHelper = new THREE.GridHelper(50, 50);
					gridHelper.visible = RDO.Tutorial.Properties.gridHelperVisible;
					scene.add(gridHelper);

					circle1 = new THREE.Line(
						new THREE.Geometry(),
						new THREE.LineBasicMaterial( { color: RDO.Tutorial.Properties.circle1Color } )
					);
					scene.add(circle1);
					
					circle2 = new THREE.Line(
						new THREE.Geometry(),
						new THREE.LineBasicMaterial( { color: RDO.Tutorial.Properties.circle2Color } )
					);
					scene.add(circle2);
					
					circle3 = new THREE.Line(
						new THREE.Geometry(),
						new THREE.LineBasicMaterial( { color: RDO.Tutorial.Properties.circle3Color } )
					);
					scene.add(circle3);
					
					lineCenterToCenter = new THREE.Line(
						new THREE.Geometry(),
						new THREE.LineBasicMaterial( { color: 0x00FFFF } )
					);
					scene.add(lineCenterToCenter);
					
					for(var i = 0; i < 3; ++i)
					{
						lineIntersectToIntersect[i] = new THREE.Line(
							new THREE.Geometry(),
							new THREE.LineBasicMaterial( { color: 0xFFFF00 } )
						);

						scene.add(lineIntersectToIntersect[i]);
					}
										
					createGeometry();
				}
				
				function createGeometry()
				{
					var intersectionPoints = [];
					
					createCircle(circle1, RDO.Tutorial.Properties.circle1CenterX, RDO.Tutorial.Properties.circle1CenterY, RDO.Tutorial.Properties.circle1Radius);
					createCircle(circle2, RDO.Tutorial.Properties.circle2CenterX, RDO.Tutorial.Properties.circle2CenterY, RDO.Tutorial.Properties.circle2Radius);
					createCircle(circle3, RDO.Tutorial.Properties.circle3CenterX, RDO.Tutorial.Properties.circle3CenterY, RDO.Tutorial.Properties.circle3Radius);
					
					
					lineCenterToCenter.geometry.dispose();
					lineCenterToCenter.geometry = new THREE.Geometry();
					lineCenterToCenter.geometry.vertices.push(new THREE.Vector3(RDO.Tutorial.Properties.circle1CenterX, RDO.Tutorial.Properties.circle1CenterY, 0));
					lineCenterToCenter.geometry.vertices.push(new THREE.Vector3(RDO.Tutorial.Properties.circle2CenterX, RDO.Tutorial.Properties.circle2CenterY, 0));
					lineCenterToCenter.geometry.vertices.push(new THREE.Vector3(RDO.Tutorial.Properties.circle3CenterX, RDO.Tutorial.Properties.circle3CenterY, 0));
					lineCenterToCenter.geometry.vertices.push(new THREE.Vector3(RDO.Tutorial.Properties.circle1CenterX, RDO.Tutorial.Properties.circle1CenterY, 0));

					
					resetOutput();
					addOutput('<b>Circle 1</b>');

					intersectionPoints[0] = calculateCircleIntersection(
						new RDO.Vector3(RDO.Tutorial.Properties.circle1CenterX, RDO.Tutorial.Properties.circle1CenterY, 0),
						RDO.Tutorial.Properties.circle1Radius,
						new RDO.Vector3(RDO.Tutorial.Properties.circle2CenterX, RDO.Tutorial.Properties.circle2CenterY, 0),
						RDO.Tutorial.Properties.circle2Radius,
						RDO.Tutorial.Properties.circleTolerance
					);
					
					addOutput('<hr>');
					addOutput('<b>Circle 2</b>');
					
					intersectionPoints[1] = calculateCircleIntersection(
						new RDO.Vector3(RDO.Tutorial.Properties.circle2CenterX, RDO.Tutorial.Properties.circle2CenterY, 0),
						RDO.Tutorial.Properties.circle2Radius,
						new RDO.Vector3(RDO.Tutorial.Properties.circle3CenterX, RDO.Tutorial.Properties.circle3CenterY, 0),
						RDO.Tutorial.Properties.circle3Radius,
						RDO.Tutorial.Properties.circleTolerance
					);
					
					addOutput('<hr>');
					addOutput('<b>Circle 3</b>');
					
					intersectionPoints[2] = calculateCircleIntersection(
						new RDO.Vector3(RDO.Tutorial.Properties.circle3CenterX, RDO.Tutorial.Properties.circle3CenterY, 0),
						RDO.Tutorial.Properties.circle3Radius,
						new RDO.Vector3(RDO.Tutorial.Properties.circle1CenterX, RDO.Tutorial.Properties.circle1CenterY, 0),
						RDO.Tutorial.Properties.circle1Radius,
						RDO.Tutorial.Properties.circleTolerance
					);
					addOutput('<hr>');

					
					for(var i = 0; i < 3; ++i)
					{
						lineIntersectToIntersect[i].geometry.dispose();
						lineIntersectToIntersect[i].geometry = new THREE.Geometry();

						if(intersectionPoints[i].length)
						{
							lineIntersectToIntersect[i].geometry.vertices.push(new THREE.Vector3(intersectionPoints[i][0].x, intersectionPoints[i][0].y, 0));
							lineIntersectToIntersect[i].geometry.vertices.push(new THREE.Vector3(intersectionPoints[i][1].x, intersectionPoints[i][1].y, 0));
						}
					}
				}
				
				function createCircle(obj, circleCenterX, circleCenterY, circleRadius)
				{
					var curve = new THREE.EllipseCurve(
						circleCenterX,
						circleCenterY,
						circleRadius,
						circleRadius,
						0,
						2 * Math.PI,
						false,
						0
					);
					
					var path = new THREE.Path(curve.getPoints(RDO.Tutorial.Properties.circlePoints));

					obj.geometry.dispose();
					obj.geometry = path.createPointsGeometry(RDO.Tutorial.Properties.circlePoints);
				}

				function createGui()
				{
					gui.add(RDO.Tutorial.Properties, 'axisHelperVisible').onChange(function(value) {
						axisHelper.visible = value;
					});
					gui.add(RDO.Tutorial.Properties, 'gridHelperVisible').onChange(function(value) {
						gridHelper.visible = value;
					});
					gui.add(RDO.Tutorial.Properties, 'circleTolerance', 0, 5).step(0.1).onChange(function(value) {
						createGeometry();
					});

					var folderCircle1 = gui.addFolder('Circle 1');
					folderCircle1.add(RDO.Tutorial.Properties, 'circle1CenterX', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle1.add(RDO.Tutorial.Properties, 'circle1CenterY', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle1.add(RDO.Tutorial.Properties, 'circle1Radius', 0.1, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle1.addColor(RDO.Tutorial.Properties, 'circle1Color').onChange(function(value) {
						circle1.material.color.setHex(cssColorToHex(value));
					});
					
					var folderCircle2 = gui.addFolder('Circle 2');
					folderCircle2.add(RDO.Tutorial.Properties, 'circle2CenterX', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle2.add(RDO.Tutorial.Properties, 'circle2CenterY', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle2.add(RDO.Tutorial.Properties, 'circle2Radius', 0.1, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle2.addColor(RDO.Tutorial.Properties, 'circle2Color').onChange(function(value) {
						circle2.material.color.setHex(cssColorToHex(value));
					});
					
					var folderCircle3 = gui.addFolder('Circle 3');
					folderCircle3.add(RDO.Tutorial.Properties, 'circle3CenterX', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle3.add(RDO.Tutorial.Properties, 'circle3CenterY', -10, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle3.add(RDO.Tutorial.Properties, 'circle3Radius', 0.1, 10).step(0.1).onChange(function(value) {
						createGeometry();
					});
					folderCircle3.addColor(RDO.Tutorial.Properties, 'circle3Color').onChange(function(value) {
						circle3.material.color.setHex(cssColorToHex(value));
					});
				}
				
				function render()
				{
					requestAnimationFrame(render);
					
					renderer.render(scene, camera);
				}
				
				function onResizeHandler(event)
				{
					camera.aspect = getCameraAspect();
					camera.updateProjectionMatrix();

					renderer.setSize(getGameAreaWidth(), getGameAreaHeight());
				}

				function getGameAreaHeight() { return canvas.offsetHeight; }
				function getGameAreaWidth() { return canvas.offsetWidth; }
				
				function getCameraAspect() { return getGameAreaWidth() / getGameAreaHeight(); }
				
				function cssColorToHex(cssColor) { return cssColor.replace('#', '0x'); }
				
				function addOutput(htmlLine)
				{
					var output = document.getElementById('output');
					
					output.innerHTML += '<div>' + htmlLine + '</div>';
				}
				
				function resetOutput()
				{
					document.getElementById('output').innerHTML = '';
				}
				
				function roundDecimal(value, decimalPlace)
				{
					var factor = Math.pow(10, decimalPlace);
					
					return Math.round(value * factor) / factor;
				}
				
				function calculateCircleIntersection(circleCenter1, circleRadius1, circleCenter2, circleRadius2, tolerance)
				{
					// compute the distance between center of the circle 1 and the circle 2
					var distanceVector = circleCenter2.sub(circleCenter1);

					// compute the length of the distance vector (Pythagorean theorem)
					var distancePow = Math.pow(distanceVector.x, 2) + Math.pow(distanceVector.y, 2);
					var distance = Math.sqrt(distancePow);
					
					addOutput('Center 1: ' + circleCenter1.toString());
					addOutput('Center 2: ' + circleCenter2.toString());
					addOutput('Distance: ' + distanceVector.toString());
					addOutput('Length  : ' + distance);

					// if the distance is 0, circle 1 and circle 2 have the same center
					if(distance == 0)
					{
						return [];
					}


					var u = (Math.pow(circleRadius1, 2) - Math.pow(circleRadius2, 2) + distancePow) / (2 * distance);
					var v = (Math.pow(circleRadius2, 2) - Math.pow(circleRadius1, 2) + distancePow) / (2 * distance);
					
					var hPow = Math.pow(circleRadius1 + tolerance, 2) - Math.pow(u, 2);
					
					addOutput('u       : ' + u);
					addOutput('v       : ' + v);
					addOutput('hPow    : ' + hPow);
					
					if(hPow < 0)
					{
						return [];
					}


					var h = Math.sqrt(hPow);
					
					var s1 = new RDO.Vector3();
					var s2 = new RDO.Vector3();
					
					s1.x = roundDecimal(circleCenter1.x + ( (u * distanceVector.x) / distance) + ( (h * distanceVector.y) / distance), 5);
					s1.y = roundDecimal(circleCenter1.y + ( (u * distanceVector.y) / distance) - ( (h * distanceVector.x) / distance), 5);
					
					s2.x = roundDecimal(circleCenter1.x + ( (u * distanceVector.x) / distance) - ( (h * distanceVector.y) / distance), 5);
					s2.y = roundDecimal(circleCenter1.y + ( (u * distanceVector.y) / distance) + ( (h * distanceVector.x) / distance), 5);
					
					addOutput('h       : ' + h);
					addOutput('S1      : ' + s1.toString());
					addOutput('S2      : ' + s2.toString());

					var distanceIntersection = s2.sub(s1);
					
					s1 = s1.sub(distanceIntersection);
					s2 = s2.add(distanceIntersection);

					return [s1, s2];
				}
				
				constructor();
			};

			document.addEventListener('DOMContentLoaded', function()
			{
				var tutorial = new RDO.Tutorial.Main(document.getElementById('webGLCanvas'));
			});
		</script>
	</body>
</html>